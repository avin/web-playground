{
  "version": 3,
  "sources": ["../../../static/root/0012-webgl-sandbox/_common/utils.ts", "../../../static/root/0012-webgl-sandbox/06-buffers/_src/shaders/bufferA.glsl", "../../../static/root/0012-webgl-sandbox/06-buffers/_src/shaders/fragment.glsl", "../../../static/root/0012-webgl-sandbox/06-buffers/_src/shaders/vertext.glsl", "../../../static/root/0012-webgl-sandbox/06-buffers/_src/index.ts"],
  "sourcesContent": ["export const createShader = (\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string,\n): WebGLShader => {\n  const shader = gl.createShader(type);\n  if (!shader) {\n    throw new Error('createShader failed');\n  }\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    // gl.deleteShader(shader);\n    throw new Error(\n      `could not compile shader: ${gl.getShaderInfoLog(shader) || ''}`,\n    );\n  }\n\n  return shader;\n};\n\nexport const createProgram = (\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram => {\n  const program = gl.createProgram();\n  if (!program) {\n    throw new Error('createProgram failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    // gl.deleteProgram(program);\n    throw new Error(\n      `program failed to link:${gl.getProgramInfoLog(program) || ''}`,\n    );\n  }\n\n  return program;\n};\n\nexport const createAndSetupTexture = (\n  gl: WebGL2RenderingContext,\n): WebGLTexture => {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Set up texture so we can render any size image and so we are\n  // working with pixels.\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  if (texture === null) {\n    throw new Error('texture create fail');\n  }\n\n  return texture;\n};\n\nexport const setCanvasSizeForTexture = (\n  gl: WebGL2RenderingContext,\n  texture: WebGLTexture,\n): void => {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  {\n    // make the texture the same size as the image\n    const mipLevel = 0; // the largest mip\n    const internalFormat = gl.RGBA; // format we want in the texture\n    const border = 0; // must be 0\n    const srcFormat = gl.RGBA; // format of data we are supplying\n    const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n    const data = null; // no data = create a blank texture\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      mipLevel,\n      internalFormat,\n      gl.canvas.width,\n      gl.canvas.height,\n      border,\n      srcFormat,\n      srcType,\n      data,\n    );\n  }\n};\n\nexport const resizeCanvasToDisplaySize = (\n  canvas: HTMLCanvasElement,\n): boolean => {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  const displayWidth = canvas.clientWidth;\n  const displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  const needResize =\n    canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n};\n", "export default `#version 300 es\nprecision highp float;in vec2 v_uv;uniform vec2 u_resolution;uniform float u_time;uniform sampler2D u_image;out vec4 outColor;\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\nvec2 rand(vec2 p){return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);}void main(){vec2 ouv=v_uv;vec2 uv=v_uv-vec2(.5);uv.x*=u_resolution.x/u_resolution.y;vec2 luv=uv;uv*=10.+sin(u_time*.5)*3.;vec2 iuv=floor(uv);vec2 guv=fract(uv);float mDist=1.0;vec3 col=vec3(0.);for(float y=-1.;y<=1.;y++){for(float x=-1.;x<=1.;x++){vec2 neighbor=vec2(x,y);vec2 point=rand(iuv+neighbor);point=0.5+0.5*sin(u_time*2.+6.2831*point);vec2 diff=neighbor+point-guv;float dist=length(diff);mDist=min(mDist,dist);}}float l=length(luv);col=hue(fract(mDist*.95+u_time*.1+l)).rgb;outColor=vec4(col,1.0)*.05+texture(u_image,ouv)*.95;}`", "export default `#version 300 es\nprecision highp float;in vec2 v_uv;uniform sampler2D u_image;out vec4 outColor;void main(){outColor=texture(u_image,v_uv);}`", "export default `#version 300 es\nin vec4 a_position;in vec2 a_uv;uniform float u_time;uniform vec2 u_resolution;out vec2 v_uv;void main(){vec4 pos=a_position;gl_Position=pos;v_uv=a_uv;}`", "import {\n  createAndSetupTexture,\n  createProgram,\n  createShader,\n  resizeCanvasToDisplaySize,\n  setCanvasSizeForTexture,\n} from '../../_common/utils';\n\nimport bufferAShaderSource from './shaders/bufferA.glsl';\nimport fragmentShaderSource from './shaders/fragment.glsl';\nimport vertexShaderSource from './shaders/vertext.glsl';\n\nvoid (() => {\n  const canvas: HTMLCanvasElement | null = document.querySelector('#canvas');\n  if (!canvas) {\n    throw new Error('no canvas');\n  }\n\n  const gl = canvas.getContext('webgl2');\n  if (!gl) {\n    throw new Error('no gl context');\n  }\n\n  // ----------\n\n  const makeAttributes = ({\n    positionAttributeLocation,\n    uvAttributeLocation,\n  }) => {\n    const vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n\n    /* ======== POSITION ========= */\n\n    /* prettier-ignore */\n    const positions = new Float32Array([\n        -1, -1,\n        1, -1,\n        1, 1,\n        -1, 1,\n      ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(\n      positionAttributeLocation,\n      2, // size - 2 components per iteration\n      gl.FLOAT, // type - the data is 32bit floats\n      false, // normalize - don't normalize the data\n      0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n      0, // offset - start at the beginning of the buffer\n    );\n\n    /* ======== UV ========= */\n\n    /* prettier-ignore */\n    const uvBufferData = new Float32Array([\n        0, 0,\n        1, 0,\n        1, 1,\n        0, 1,\n      ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, uvBufferData, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(uvAttributeLocation);\n    gl.vertexAttribPointer(\n      uvAttributeLocation,\n      2, // size - 2 components per iteration\n      gl.FLOAT, // type - the data is 32bit floats\n      false, // normalize - don't normalize the data\n      0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n      0, // offset - start at the beginning of the buffer\n    );\n\n    /* ======== INDICES ========= */\n\n    /* prettier-ignore */\n    const indices = new Uint16Array([\n        0, 1, 3,   // first triangle\n        3, 1, 2,   // second triangle\n      ]);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint16Array(indices),\n      gl.STATIC_DRAW,\n    );\n\n    /* ======== CLEAN ========= */\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n    return vao;\n  };\n\n  const imageProgramObj = (() => {\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(\n      gl,\n      gl.FRAGMENT_SHADER,\n      fragmentShaderSource,\n    );\n\n    const program = createProgram(gl, vertexShader, fragmentShader);\n\n    const positionAttributeLocation = gl.getAttribLocation(\n      program,\n      'a_position',\n    );\n    const uvAttributeLocation = gl.getAttribLocation(program, 'a_uv');\n\n    const timeLocation = gl.getUniformLocation(program, 'u_time');\n    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n    const imageLocation = gl.getUniformLocation(program, 'u_image');\n\n    const vao = makeAttributes({\n      positionAttributeLocation,\n      uvAttributeLocation,\n    });\n\n    return {\n      vao,\n      program,\n      uniforms: {\n        timeLocation,\n        resolutionLocation,\n        imageLocation,\n      },\n    };\n  })();\n\n  const bufferAProgramObj = (() => {\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(\n      gl,\n      gl.FRAGMENT_SHADER,\n      bufferAShaderSource,\n    );\n\n    const program = createProgram(gl, vertexShader, fragmentShader);\n\n    const positionAttributeLocation = gl.getAttribLocation(\n      program,\n      'a_position',\n    );\n    const uvAttributeLocation = gl.getAttribLocation(program, 'a_uv');\n\n    const timeLocation = gl.getUniformLocation(program, 'u_time');\n    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n    const imageLocation = gl.getUniformLocation(program, 'u_image');\n\n    const vao = makeAttributes({\n      positionAttributeLocation,\n      uvAttributeLocation,\n    });\n\n    return {\n      vao,\n      program,\n      uniforms: {\n        timeLocation,\n        resolutionLocation,\n        imageLocation,\n      },\n    };\n  })();\n\n  const backTexture = createAndSetupTexture(gl);\n  const texture = createAndSetupTexture(gl);\n\n  // Create a framebuffer\n  const fbo = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n  const attachmentPoint = gl.COLOR_ATTACHMENT0;\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    attachmentPoint,\n    gl.TEXTURE_2D,\n    texture,\n    0,\n  );\n\n  const startTime = +new Date();\n\n  (function frame() {\n    const time = (+new Date() - startTime) / 1000;\n\n    const isNeedResize = resizeCanvasToDisplaySize(\n      gl.canvas as HTMLCanvasElement,\n    );\n    if (isNeedResize) {\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n      setCanvasSizeForTexture(gl, texture);\n      setCanvasSizeForTexture(gl, backTexture);\n    }\n\n    // Clear the canvas\n    gl.clearColor(0, 0, 0, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // -----------------------------\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(bufferAProgramObj.program);\n\n    gl.uniform1f(bufferAProgramObj.uniforms.timeLocation, time);\n    gl.uniform2fv(bufferAProgramObj.uniforms.resolutionLocation, [\n      gl.canvas.width,\n      gl.canvas.height,\n    ]);\n\n    gl.activeTexture(gl.TEXTURE0 + 0);\n    gl.bindTexture(gl.TEXTURE_2D, backTexture);\n    gl.uniform1i(bufferAProgramObj.uniforms.imageLocation, 0);\n\n    gl.bindVertexArray(bufferAProgramObj.vao);\n\n    gl.drawElements(\n      gl.TRIANGLES,\n      6, // count\n      gl.UNSIGNED_SHORT, // indexType\n      0, // offset\n    );\n\n    gl.bindVertexArray(null);\n\n    gl.bindTexture(gl.TEXTURE_2D, backTexture);\n    gl.copyTexImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      0,\n      0,\n      canvas.clientWidth,\n      canvas.clientHeight,\n      0,\n    );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // -----------------------------\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(imageProgramObj.program);\n\n    gl.bindVertexArray(imageProgramObj.vao);\n\n    gl.uniform1f(imageProgramObj.uniforms.timeLocation, time);\n    gl.uniform2fv(imageProgramObj.uniforms.resolutionLocation, [\n      gl.canvas.width,\n      gl.canvas.height,\n    ]);\n\n    gl.activeTexture(gl.TEXTURE0 + 0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    gl.uniform1i(imageProgramObj.uniforms.imageLocation, 0);\n\n    gl.drawElements(\n      gl.TRIANGLES,\n      6, // count\n      gl.UNSIGNED_SHORT, // indexType\n      0, // offset\n    );\n\n    gl.bindVertexArray(null);\n\n    requestAnimationFrame(frame);\n  })();\n})();\n"],
  "mappings": "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",
  "names": ["createShader", "gl", "type", "source", "shader", "createProgram", "vertexShader", "fragmentShader", "program", "createAndSetupTexture", "texture", "setCanvasSizeForTexture", "internalFormat", "border", "srcFormat", "srcType", "data", "resizeCanvasToDisplaySize", "canvas", "displayWidth", "displayHeight", "needResize", "bufferA_default", "fragment_default", "vertext_default", "canvas", "gl", "makeAttributes", "positionAttributeLocation", "uvAttributeLocation", "vao", "positions", "uvBufferData", "indices", "imageProgramObj", "vertexShader", "createShader", "vertext_default", "fragmentShader", "fragment_default", "program", "createProgram", "timeLocation", "resolutionLocation", "imageLocation", "bufferAProgramObj", "bufferA_default", "backTexture", "createAndSetupTexture", "texture", "fbo", "attachmentPoint", "startTime", "frame", "time", "resizeCanvasToDisplaySize", "setCanvasSizeForTexture"]
}
