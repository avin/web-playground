{
  "version": 3,
  "sources": ["../../../static/root/0012-webgl-sandbox/_common/utils.ts", "../../../static/root/0012-webgl-sandbox/04-instances/_src/shaders/fragment.glsl", "../../../static/root/0012-webgl-sandbox/04-instances/_src/shaders/vertext.glsl", "../../../static/root/0012-webgl-sandbox/04-instances/_src/index.ts"],
  "sourcesContent": ["export const createShader = (\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string,\n): WebGLShader => {\n  const shader = gl.createShader(type);\n  if (!shader) {\n    throw new Error('createShader failed');\n  }\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    // gl.deleteShader(shader);\n    throw new Error(\n      `could not compile shader: ${gl.getShaderInfoLog(shader) || ''}`,\n    );\n  }\n\n  return shader;\n};\n\nexport const createProgram = (\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram => {\n  const program = gl.createProgram();\n  if (!program) {\n    throw new Error('createProgram failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    // gl.deleteProgram(program);\n    throw new Error(\n      `program failed to link:${gl.getProgramInfoLog(program) || ''}`,\n    );\n  }\n\n  return program;\n};\n\nexport const createAndSetupTexture = (\n  gl: WebGL2RenderingContext,\n): WebGLTexture => {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Set up texture so we can render any size image and so we are\n  // working with pixels.\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  if (texture === null) {\n    throw new Error('texture create fail');\n  }\n\n  return texture;\n};\n\nexport const setCanvasSizeForTexture = (\n  gl: WebGL2RenderingContext,\n  texture: WebGLTexture,\n): void => {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  {\n    // make the texture the same size as the image\n    const mipLevel = 0; // the largest mip\n    const internalFormat = gl.RGBA; // format we want in the texture\n    const border = 0; // must be 0\n    const srcFormat = gl.RGBA; // format of data we are supplying\n    const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n    const data = null; // no data = create a blank texture\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      mipLevel,\n      internalFormat,\n      gl.canvas.width,\n      gl.canvas.height,\n      border,\n      srcFormat,\n      srcType,\n      data,\n    );\n  }\n};\n\nexport const resizeCanvasToDisplaySize = (\n  canvas: HTMLCanvasElement,\n): boolean => {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  const displayWidth = canvas.clientWidth;\n  const displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  const needResize =\n    canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n};\n", "export default `#version 300 es\nprecision highp float;in vec3 v_color;out vec4 outColor;void main(){outColor=vec4(v_color,.5);}`", "export default `#version 300 es\nin vec4 a_position;in vec2 a_offset;in float a_rotation;in vec3 a_color;in float a_speed;uniform float u_time;uniform vec2 u_resolution;out vec3 v_color;void rotate(in float angle,inout vec2 uv){float ca=cos(angle);float sa=sin(angle);uv*=mat2(ca,-sa,sa,ca);}void main(){vec4 pos=a_position;rotate(u_time*a_speed+float(gl_InstanceID),pos.xy);pos.x*=u_resolution.y/u_resolution.x;pos=pos+vec4(a_offset,0.,0.);gl_Position=pos;v_color=a_color;}`", "import {\n  createProgram,\n  createShader,\n  resizeCanvasToDisplaySize,\n} from '../../_common/utils';\n\nimport fragmentShaderSource from './shaders/fragment.glsl';\nimport vertexShaderSource from './shaders/vertext.glsl';\n\nvoid (() => {\n  // @ts-ignore\n  const stats = new window.Stats();\n  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n  document.body.appendChild(stats.dom);\n\n  const canvas: HTMLCanvasElement | null = document.querySelector('#canvas');\n  if (!canvas) {\n    throw new Error('no canvas');\n  }\n\n  const gl = canvas.getContext('webgl2');\n  if (!gl) {\n    throw new Error('no gl context');\n  }\n\n  gl.enable(gl.BLEND);\n  gl.blendFuncSeparate(\n    gl.SRC_ALPHA,\n    gl.ONE_MINUS_SRC_ALPHA,\n    gl.ONE,\n    gl.ONE_MINUS_SRC_ALPHA,\n  );\n  // gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE );\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  const fragmentShader = createShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource,\n  );\n\n  const program = createProgram(gl, vertexShader, fragmentShader);\n\n  const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n  const offsetAttributeLocation = gl.getAttribLocation(program, 'a_offset');\n  const colorAttributeLocation = gl.getAttribLocation(program, 'a_color');\n  const speedAttributeLocation = gl.getAttribLocation(program, 'a_speed');\n\n  const timeLocation = gl.getUniformLocation(program, 'u_time');\n  const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n\n  const numInstances = 5000;\n\n  const offsetData = new Float32Array(numInstances * 2);\n  const rotationData = new Float32Array(numInstances * 1);\n  const colorData = new Float32Array(numInstances * 3);\n  const speedData = new Float32Array(numInstances * 1);\n\n  const colorsStorage: Float32Array[] = [];\n  const rotationsStorage: Float32Array[] = [];\n  const offsetsStorage: Float32Array[] = [];\n  const speedsStorage: Float32Array[] = [];\n  for (let i = 0; i < numInstances; i += 1) {\n    offsetsStorage.push(new Float32Array(offsetData.buffer, i * 2 * 4, 2));\n    rotationsStorage.push(new Float32Array(rotationData.buffer, i * 1 * 4, 1));\n    colorsStorage.push(new Float32Array(colorData.buffer, i * 3 * 4, 3));\n    speedsStorage.push(new Float32Array(speedData.buffer, i * 1 * 4, 1));\n  }\n\n  offsetsStorage.forEach((item) => {\n    item[0] = Math.random() * 2 - 1;\n    item[1] = Math.random() * 2 - 1;\n  });\n\n  rotationsStorage.forEach((item) => {\n    item[0] = Math.random();\n  });\n\n  colorsStorage.forEach((item) => {\n    item[0] = Math.random();\n    item[1] = Math.random();\n    item[2] = Math.random();\n  });\n\n  speedsStorage.forEach((item) => {\n    item[0] = Math.random() * 2 + 0.5;\n  });\n\n  const vao = gl.createVertexArray();\n  gl.bindVertexArray(vao);\n\n  {\n    /* ======== POSITION ========= */\n\n    const size = 0.025;\n    /* prettier-ignore */\n    const positions = new Float32Array([\n      -size, -size,\n      size, -size,\n      size, size,\n      -size, size,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(\n      positionAttributeLocation,\n      2, // size - 2 components per iteration\n      gl.FLOAT, // type - the data is 32bit floats\n      false, // normalize - don't normalize the data\n      0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n      0, // offset - start at the beginning of the buffer\n    );\n\n    /* ======== INDICES ========= */\n\n    /* prettier-ignore */\n    const indices = new Uint16Array([\n      0, 1, 3,   // first triangle\n      3, 1, 2,   // second triangle\n    ]);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint16Array(indices),\n      gl.STATIC_DRAW,\n    );\n\n    /* ======== OFFSETS ========= */\n\n    const offsetBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, offsetData, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(offsetAttributeLocation);\n    gl.vertexAttribPointer(offsetAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribDivisor(offsetAttributeLocation, 1);\n\n    /* ======== COLORS ========= */\n\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(colorAttributeLocation);\n    gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribDivisor(colorAttributeLocation, 1);\n\n    /* ======== SPEEDS ========= */\n\n    const speedBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, speedBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, speedData, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(speedAttributeLocation);\n    gl.vertexAttribPointer(speedAttributeLocation, 1, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribDivisor(speedAttributeLocation, 1);\n\n    /* ======== CLEAN ========= */\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  const startTime = +new Date();\n\n  (function frame() {\n    stats.begin();\n    const time = (+new Date() - startTime) / 1000;\n\n    const isNeedResize = resizeCanvasToDisplaySize(\n      gl.canvas as HTMLCanvasElement,\n    );\n    if (isNeedResize) {\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    }\n\n    // Clear the canvas\n    gl.clearColor(1, 1, 1, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program);\n\n    gl.uniform1f(timeLocation, time);\n    gl.uniform2fv(resolutionLocation, [gl.canvas.width, gl.canvas.height]);\n\n    gl.bindVertexArray(vao);\n\n    gl.drawElementsInstanced(\n      gl.TRIANGLES,\n      6, // count\n      gl.UNSIGNED_SHORT, // indexType\n      0, // offset\n      numInstances, // num instances\n    );\n\n    gl.bindVertexArray(null);\n\n    // gl.drawElements(\n    //   gl.TRIANGLES, // primitiveType\n    //   6, // count\n    //   gl.UNSIGNED_SHORT, // indexType\n    //   0, // offset\n    // );\n\n    stats.end();\n    requestAnimationFrame(frame);\n  })();\n})();\n"],
  "mappings": "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",
  "names": ["createShader", "gl", "type", "source", "shader", "createProgram", "vertexShader", "fragmentShader", "program", "resizeCanvasToDisplaySize", "canvas", "displayWidth", "displayHeight", "needResize", "fragment_default", "vertext_default", "stats", "canvas", "gl", "vertexShader", "createShader", "vertext_default", "fragmentShader", "fragment_default", "program", "createProgram", "positionAttributeLocation", "offsetAttributeLocation", "colorAttributeLocation", "speedAttributeLocation", "timeLocation", "resolutionLocation", "numInstances", "offsetData", "rotationData", "colorData", "speedData", "colorsStorage", "rotationsStorage", "offsetsStorage", "speedsStorage", "i", "item", "vao", "positions", "indices", "offsetBuffer", "colorBuffer", "speedBuffer", "startTime", "frame", "time", "resizeCanvasToDisplaySize"]
}
