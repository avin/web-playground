{
  "version": 3,
  "sources": ["../../../static/root/0012-webgl-sandbox/09-syntwave-vert/_src/shaders/fragment.glsl", "../../../static/root/0012-webgl-sandbox/09-syntwave-vert/_src/shaders/vertext.glsl", "../../../static/root/0012-webgl-sandbox/09-syntwave-vert/_src/index.js"],
  "sourcesContent": ["export default `precision highp float;uniform float iTime;uniform vec2 iResolution;uniform vec3 backColor;uniform float count;varying float vIdx;varying float vUseColor;\n#define DYNAMIC_COLOR 1\n#define hue(h) clamp(abs(fract(h + vec4(3, 2, 1, 0) / 3.) * 6. - 3.) - 1., 0., 1.)\nvoid main(){vec3 baseColor=backColor;if(vUseColor>.5){float hueFactor=vIdx/count;if(DYNAMIC_COLOR==1){hueFactor+=iTime*.1;}vec3 col=hue(hueFactor).rgb;baseColor.rgb=col;}gl_FragColor=vec4(baseColor,1.);}`", "export default `precision highp float;attribute vec2 a_position;attribute float a_idx;attribute float a_useColor;attribute float a_offset;uniform float count;uniform float iTime;uniform vec2 iResolution;uniform float sizeFactor;varying float vIdx;varying float vUseColor;\n#define MOD3 vec3(.1031, .11369, .13787)\nvec3 hash33(vec3 p3){p3=fract(p3*MOD3);p3+=dot(p3,p3.yxz+19.19);return-1.0+2.0*fract(vec3((p3.x+p3.y)*p3.z,(p3.x+p3.z)*p3.y,(p3.y+p3.z)*p3.x));}float noise(vec3 p){const float K1=0.333333333;const float K2=0.166666667;vec3 i=floor(p+(p.x+p.y+p.z)*K1);vec3 d0=p-(i-(i.x+i.y+i.z)*K2);vec3 e=step(vec3(0.0),d0-d0.yzx);vec3 i1=e*(1.0-e.zxy);vec3 i2=1.0-e.zxy*(1.0-e);vec3 d1=d0-(i1-1.0*K2);vec3 d2=d0-(i2-2.0*K2);vec3 d3=d0-(1.0-3.0*K2);vec4 h=max(0.6-vec4(dot(d0,d0),dot(d1,d1),dot(d2,d2),dot(d3,d3)),0.0);vec4 n=h*h*h*h*vec4(dot(d0,hash33(i)),dot(d1,hash33(i+i1)),dot(d2,hash33(i+i2)),dot(d3,hash33(i+1.0)));return dot(vec4(31.316),n);}void main(void){vec3 positionUpdated=vec3(a_position,a_idx/(count*3.));positionUpdated.x*=2.;float idx=a_idx-count/2.;vIdx=idx;vUseColor=a_useColor;float t=iTime*.5;float xFactor=positionUpdated.x;float moveFactor=noise(vec3(xFactor*sizeFactor,idx*.15-t,1.))*.25;moveFactor*=step(.5,positionUpdated.y);positionUpdated.y+=moveFactor;positionUpdated.y-=a_offset+.5;gl_Position=vec4(positionUpdated,1.0);}`", "// @process\n\nimport fragmentShaderSrc from './shaders/fragment.glsl';\nimport vertexShaderSrc from './shaders/vertext.glsl';\n\nconst VERT_ACCURACY = 0.03; // \u0420\u0430\u0441\u0441\u0442\u043E\u044F\u043D\u0438\u0435 \u043C\u0435\u0436\u0434\u0443 \u043B\u0438\u043D\u0438\u044F\u043C\u0438\nconst CONGESTION = 700; // \u041A\u0443\u0447\u043D\u043E\u0441\u0442\u044C \u0432\u043E\u043B\u043D\nconst LINES_COUNT = 20; // \u0427\u0438\u0441\u043B\u043E \u043B\u0438\u043D\u0438\u0439\nconst SHADOW_SIZE = 0.012; // \u0422\u043E\u043B\u0449\u0438\u043D\u0430 \u0442\u0435\u043D\u0438\nconst LINE_SIZE = 0.01; // \u0422\u043E\u043B\u0449\u0438\u043D\u0430 \u043B\u0438\u043D\u0438\u0438\nconst BACK_COLOR = [23 / 255, 32 / 255, 38 / 255]; // \u0426\u0432\u0435\u0442 \u0444\u043E\u043D\u0430\nconst COMMON_OFFSET = 0; // \u0421\u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0446\u0435\u043D\u0442\u0440\u0430\nconst FRAGMENTS = 200; // \u0427\u0438\u0441\u043B\u043E \u0444\u0440\u0430\u0433\u043C\u0435\u043D\u0442\u043E\u0432 (\u043F\u043B\u0430\u0432\u043D\u043E\u0441\u0442\u044C \u043B\u0438\u043D\u0438\u0439)\n\nconst canvas = document.querySelector('#canvas');\nconst gl =\n  canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\nconst devicePixelRatio = window.devicePixelRatio || 1;\n\nconst ext = gl.getExtension('ANGLE_instanced_arrays');\nif (!ext) {\n  throw new Error('no instances');\n}\n\nconst resizeCanvasToDisplaySize = (canvas) => {\n  const displayWidth = canvas.clientWidth;\n  const displayHeight = canvas.clientHeight;\n\n  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n    canvas.width = displayWidth * devicePixelRatio;\n    canvas.height = displayHeight * devicePixelRatio;\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  }\n};\n\nconst buildPlane = (\n  width = 1,\n  height = 1,\n  widthSegments = 1,\n  heightSegments = 1,\n) => {\n  const wSegs = widthSegments;\n  const hSegs = heightSegments;\n\n  const num = (wSegs + 1) * (hSegs + 1);\n  const numIndices = wSegs * hSegs * 6;\n\n  const position = new Float32Array(num * 3);\n  const normal = new Float32Array(num * 3);\n  const uv = new Float32Array(num * 2);\n  const index =\n    numIndices > 65536\n      ? new Uint32Array(numIndices)\n      : new Uint16Array(numIndices);\n\n  let u = 0;\n  let v = 1;\n  let w = 2;\n  let uDir = 1;\n  let vDir = -1;\n  let i = 0;\n  let ii = 0;\n  let depth = 0;\n\n  const io = i;\n  const segW = width / wSegs;\n  const segH = height / hSegs;\n\n  for (let iy = 0; iy <= hSegs; iy++) {\n    let y = iy * segH - height / 2;\n    for (let ix = 0; ix <= wSegs; ix++, i++) {\n      let x = ix * segW - width / 2;\n\n      position[i * 3 + u] = x * uDir;\n      position[i * 3 + v] = y * vDir;\n      position[i * 3 + w] = depth / 2;\n\n      normal[i * 3 + u] = 0;\n      normal[i * 3 + v] = 0;\n      normal[i * 3 + w] = depth >= 0 ? 1 : -1;\n\n      uv[i * 2] = ix / wSegs;\n      uv[i * 2 + 1] = 1 - iy / hSegs;\n\n      if (iy === hSegs || ix === wSegs) continue;\n      let a = io + ix + iy * (wSegs + 1);\n      let b = io + ix + (iy + 1) * (wSegs + 1);\n      let c = io + ix + (iy + 1) * (wSegs + 1) + 1;\n      let d = io + ix + iy * (wSegs + 1) + 1;\n\n      index[ii * 6] = a;\n      index[ii * 6 + 1] = b;\n      index[ii * 6 + 2] = d;\n      index[ii * 6 + 3] = b;\n      index[ii * 6 + 4] = c;\n      index[ii * 6 + 5] = d;\n      ii++;\n    }\n  }\n\n  return {\n    position: { size: 3, data: position },\n    normal: { size: 3, data: normal },\n    uv: { size: 2, data: uv },\n    index: { data: index },\n  };\n};\n\nconst plane = buildPlane(1, 1, FRAGMENTS, 1);\n\nconst meshesCount = LINES_COUNT;\n\nconst idxArr = [];\nconst useColorArr = [];\nconst offsetArr = [];\n\nlet idx = 0;\nfor (let n = 0; n < meshesCount * 3; n += 1) {\n  for (let i = 0; i < 3; i += 1) {\n    const step = i === 1 ? SHADOW_SIZE : LINE_SIZE;\n    idxArr[idx] = n - meshesCount / 2;\n    useColorArr[idx] = i === 1 ? 1 : 0;\n    offsetArr[idx] =\n      i * step + (n - meshesCount / 2) * VERT_ACCURACY - COMMON_OFFSET;\n\n    idx += 1;\n  }\n}\n\nconsole.log(offsetArr);\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER);\ngl.shaderSource(vertexShader, vertexShaderSrc);\ngl.compileShader(vertexShader);\nif (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n  throw new Error(\n    `could not compile shader: ${gl.getShaderInfoLog(vertexShader) || ''}`,\n  );\n}\n\nconst pixelShader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(pixelShader, fragmentShaderSrc);\ngl.compileShader(pixelShader);\nif (!gl.getShaderParameter(pixelShader, gl.COMPILE_STATUS)) {\n  throw new Error(\n    `could not compile shader: ${gl.getShaderInfoLog(pixelShader) || ''}`,\n  );\n}\n\nconst program = gl.createProgram();\ngl.attachShader(program, vertexShader);\ngl.attachShader(program, pixelShader);\ngl.linkProgram(program);\ngl.useProgram(program);\n\nconst positionLoc = gl.getAttribLocation(program, 'a_position');\nconst idxLoc = gl.getAttribLocation(program, 'a_idx');\nconst useColorLoc = gl.getAttribLocation(program, 'a_useColor');\nconst offsetLoc = gl.getAttribLocation(program, 'a_offset');\n\nconst iTimeLoc = gl.getUniformLocation(program, 'iTime');\nconst iResolutionLoc = gl.getUniformLocation(program, 'iResolution');\nconst sizeFactorLoc = gl.getUniformLocation(program, 'sizeFactor');\nconst countLoc = gl.getUniformLocation(program, 'count');\nconst backColorLoc = gl.getUniformLocation(program, 'backColor');\n\nconst positionBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, plane.position.data, gl.STATIC_DRAW);\n\nconst idxBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, idxBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(idxArr), gl.STATIC_DRAW);\n\nconst useColorBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, useColorBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(useColorArr), gl.STATIC_DRAW);\n\nconst offsetBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(offsetArr), gl.STATIC_DRAW);\n\nconst indexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, plane.index.data, gl.STATIC_DRAW);\n\n// ----------\n\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.enableVertexAttribArray(positionLoc);\ngl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);\n\ngl.bindBuffer(gl.ARRAY_BUFFER, idxBuffer);\ngl.enableVertexAttribArray(idxLoc);\ngl.vertexAttribPointer(idxLoc, 1, gl.FLOAT, false, 0, 0);\next.vertexAttribDivisorANGLE(idxLoc, 1);\n\ngl.bindBuffer(gl.ARRAY_BUFFER, useColorBuffer);\ngl.enableVertexAttribArray(useColorLoc);\ngl.vertexAttribPointer(useColorLoc, 1, gl.FLOAT, false, 0, 0);\next.vertexAttribDivisorANGLE(useColorLoc, 1);\n\ngl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);\ngl.enableVertexAttribArray(offsetLoc);\ngl.vertexAttribPointer(offsetLoc, 1, gl.FLOAT, false, 0, 0);\next.vertexAttribDivisorANGLE(offsetLoc, 1);\n\nfunction loop(time) {\n  resizeCanvasToDisplaySize(canvas);\n\n  gl.clearColor(BACK_COLOR[0], BACK_COLOR[1], BACK_COLOR[2], 1);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  gl.uniform1f(iTimeLoc, time / 1000);\n  gl.uniform1f(\n    sizeFactorLoc,\n    (canvas.clientWidth * devicePixelRatio) / CONGESTION,\n  );\n  gl.uniform1f(countLoc, meshesCount);\n  gl.uniform3fv(backColorLoc, BACK_COLOR);\n  gl.uniform2f(\n    iResolutionLoc,\n    canvas.clientWidth * devicePixelRatio,\n    canvas.clientHeight * devicePixelRatio,\n  );\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n  // gl.drawElements(gl.TRIANGLES, plane.index.data.length, gl.UNSIGNED_SHORT, 0);\n  ext.drawElementsInstancedANGLE(\n    gl.TRIANGLES,\n    plane.index.data.length,\n    gl.UNSIGNED_SHORT,\n    0,\n    meshesCount * 3,\n  );\n\n  window.requestAnimationFrame(loop);\n}\nloop();\n"],
  "mappings": "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",
  "names": ["fragment_default", "vertext_default", "VERT_ACCURACY", "CONGESTION", "LINES_COUNT", "SHADOW_SIZE", "LINE_SIZE", "BACK_COLOR", "COMMON_OFFSET", "FRAGMENTS", "canvas", "gl", "devicePixelRatio", "ext", "resizeCanvasToDisplaySize", "displayWidth", "displayHeight", "buildPlane", "width", "height", "widthSegments", "heightSegments", "wSegs", "hSegs", "num", "numIndices", "position", "normal", "uv", "index", "u", "v", "w", "uDir", "vDir", "i", "ii", "depth", "io", "segW", "segH", "iy", "y", "ix", "x", "a", "b", "c", "d", "plane", "meshesCount", "idxArr", "useColorArr", "offsetArr", "idx", "n", "step", "vertexShader", "vertext_default", "pixelShader", "fragment_default", "program", "positionLoc", "idxLoc", "useColorLoc", "offsetLoc", "iTimeLoc", "iResolutionLoc", "sizeFactorLoc", "countLoc", "backColorLoc", "positionBuffer", "idxBuffer", "useColorBuffer", "offsetBuffer", "indexBuffer", "loop", "time"]
}
