{
  "version": 3,
  "sources": ["../../../static/root/0012-webgl-sandbox/_common/utils.ts", "../../../static/root/0012-webgl-sandbox/03-square/_src/shaders/fragment.glsl", "../../../static/root/0012-webgl-sandbox/03-square/_src/shaders/vertext.glsl", "../../../static/root/0012-webgl-sandbox/03-square/_src/index.ts"],
  "sourcesContent": ["export const createShader = (\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string,\n): WebGLShader => {\n  const shader = gl.createShader(type);\n  if (!shader) {\n    throw new Error('createShader failed');\n  }\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    // gl.deleteShader(shader);\n    throw new Error(\n      `could not compile shader: ${gl.getShaderInfoLog(shader) || ''}`,\n    );\n  }\n\n  return shader;\n};\n\nexport const createProgram = (\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram => {\n  const program = gl.createProgram();\n  if (!program) {\n    throw new Error('createProgram failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    // gl.deleteProgram(program);\n    throw new Error(\n      `program failed to link:${gl.getProgramInfoLog(program) || ''}`,\n    );\n  }\n\n  return program;\n};\n\nexport const createAndSetupTexture = (\n  gl: WebGL2RenderingContext,\n): WebGLTexture => {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Set up texture so we can render any size image and so we are\n  // working with pixels.\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  if (texture === null) {\n    throw new Error('texture create fail');\n  }\n\n  return texture;\n};\n\nexport const setCanvasSizeForTexture = (\n  gl: WebGL2RenderingContext,\n  texture: WebGLTexture,\n): void => {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  {\n    // make the texture the same size as the image\n    const mipLevel = 0; // the largest mip\n    const internalFormat = gl.RGBA; // format we want in the texture\n    const border = 0; // must be 0\n    const srcFormat = gl.RGBA; // format of data we are supplying\n    const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n    const data = null; // no data = create a blank texture\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      mipLevel,\n      internalFormat,\n      gl.canvas.width,\n      gl.canvas.height,\n      border,\n      srcFormat,\n      srcType,\n      data,\n    );\n  }\n};\n\nexport const resizeCanvasToDisplaySize = (\n  canvas: HTMLCanvasElement,\n): boolean => {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  const displayWidth = canvas.clientWidth;\n  const displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  const needResize =\n    canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n};\n", "export default `#version 300 es\nprecision highp float;uniform sampler2D u_image1;uniform sampler2D u_image2;uniform float u_time;in vec2 v_texCoord;out vec4 outColor;vec3 getCol1(vec2 uv){vec3 col=texture(u_image1,uv).rgb;float t=u_time*10.;float offsetFactor=t+v_texCoord.x*10.;bool isHair=!((abs(col.r-col.g)<.25)&&(abs(col.g-col.b)<.25));if(isHair){col.r=texture(u_image1,v_texCoord+vec2(sin(offsetFactor)*.01,0.)).r;col.g=texture(u_image1,v_texCoord-vec2(cos(offsetFactor)*.01,0.)).g;}return col;}vec3 getCol2(vec2 uv){vec3 col=texture(u_image2,uv).rgb;float t=u_time*5.;float offsetFactor=t+v_texCoord.y*20.;col.r=texture(u_image2,v_texCoord+vec2(sin(offsetFactor)*.01,0.)).r;col.g=texture(u_image2,v_texCoord-vec2(cos(offsetFactor)*.01,0.)).g;return col;}void main(){float s=sin(u_time)*.6+.5;float f=smoothstep(-.1+s,.1+s,v_texCoord.x);vec2 uv=v_texCoord;vec3 col1=getCol1(uv);vec3 col2=getCol2(uv);vec3 col=mix(col1,col2,f);outColor=vec4(col,1.);}`", "export default `#version 300 es\nin vec4 a_position;in vec2 a_texCoord;uniform vec2 u_resolution;out vec2 v_texCoord;void main(){vec4 pos=a_position;pos.x*=u_resolution.y/u_resolution.x;gl_Position=pos;v_texCoord=a_texCoord;}`", "import {\n  createProgram,\n  createShader,\n  resizeCanvasToDisplaySize,\n} from '../../_common/utils';\n\nimport fragmentShaderSource from './shaders/fragment.glsl';\nimport vertexShaderSource from './shaders/vertext.glsl';\n\nconst loadImage = (url) => {\n  return new Promise((resolve) => {\n    const image = new Image();\n    image.src = url;\n    image.onload = () => {\n      resolve(image);\n    };\n  });\n};\n\nvoid (async () => {\n  const images = await Promise.all([\n    loadImage('../assets/img/Di-3d.png'),\n    loadImage('../assets/img/leaves.jpg'),\n  ]);\n\n  const canvas: HTMLCanvasElement | null = document.querySelector('#canvas');\n  if (!canvas) {\n    throw new Error('no canvas');\n  }\n\n  const gl = canvas.getContext('webgl2');\n  if (!gl) {\n    throw new Error('no gl context');\n  }\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  const fragmentShader = createShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource,\n  );\n\n  const program = createProgram(gl, vertexShader, fragmentShader);\n\n  const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n  const texCoordAttributeLocation = gl.getAttribLocation(program, 'a_texCoord');\n\n  const image1Location = gl.getUniformLocation(program, 'u_image1');\n  const image2Location = gl.getUniformLocation(program, 'u_image2');\n  const timeLocation = gl.getUniformLocation(program, 'u_time');\n  const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n\n  const createTexture = (textureIndex: number, image: ImageBitmap) => {\n    const texture = gl.createTexture();\n\n    gl.activeTexture(gl.TEXTURE0 + textureIndex);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0, // mipLevel,\n      gl.RGBA, // internalFormat,\n      gl.RGBA, // srcFormat,\n      gl.UNSIGNED_BYTE, // srcType,\n      image,\n    );\n\n    return texture;\n  };\n\n  const texture1 = createTexture(0, images[0] as ImageBitmap);\n  const texture2 = createTexture(1, images[1] as ImageBitmap);\n\n  const vao1 = gl.createVertexArray();\n  gl.bindVertexArray(vao1);\n\n  {\n    /* ======== POSITION ========= */\n\n    /* prettier-ignore */\n    const positions = new Float32Array([\n      -0.5, -0.5,\n      0.5, -0.5,\n      0.5, 0.5,\n      -0.5, 0.5,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(\n      positionAttributeLocation,\n      2, // size - 2 components per iteration\n      gl.FLOAT, // type - the data is 32bit floats\n      false, // normalize - don't normalize the data\n      0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n      0, // offset - start at the beginning of the buffer\n    );\n\n    /* ======== TEX_COORDS ========= */\n\n    /* prettier-ignore */\n    const texCoords = new Float32Array([\n      0.0,  1.0,\n      1.0,  1.0,\n      1.0,  0.0,\n      0.0,  0.0,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(texCoordAttributeLocation);\n    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n    /* ======== INDICES ========= */\n\n    /* prettier-ignore */\n    const indices = new Uint16Array([\n      0, 1, 3,   // first triangle\n      3, 1, 2,   // second triangle\n    ]);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint16Array(indices),\n      gl.STATIC_DRAW,\n    );\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  const vao2 = gl.createVertexArray();\n  gl.bindVertexArray(vao2);\n\n  {\n    /* ======== POSITION ========= */\n\n    /* prettier-ignore */\n    const positions = new Float32Array([\n      -0.9, -0.7,\n      -0.7, -0.9,\n      -0.5, -0.7,\n      -0.7, -0.5,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(\n      positionAttributeLocation,\n      2, // size - 2 components per iteration\n      gl.FLOAT, // type - the data is 32bit floats\n      false, // normalize - don't normalize the data\n      0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n      0, // offset - start at the beginning of the buffer\n    );\n\n    /* ======== TEX_COORDS ========= */\n\n    /* prettier-ignore */\n    const texCoords = new Float32Array([\n      0.0,  1.0,\n      1.0,  1.0,\n      1.0,  0.0,\n      0.0,  0.0,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(texCoordAttributeLocation);\n    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n    /* ======== INDICES ========= */\n\n    /* prettier-ignore */\n    const indices = new Uint16Array([\n      0, 1, 2,   // first triangle\n      2, 3, 0,   // second triangle\n    ]);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint16Array(indices),\n      gl.STATIC_DRAW,\n    );\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  const vao3 = gl.createVertexArray();\n  gl.bindVertexArray(vao3);\n\n  {\n    /* ======== POSITION ========= */\n\n    /* prettier-ignore */\n    const positions = new Float32Array([\n      0.5, 0.8,\n      0.6, 0.6,\n      0.7, 0.8,\n      0.8, 0.6,\n      0.9, 0.8,\n      1.0, 0.6,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(\n      positionAttributeLocation,\n      2, // size - 2 components per iteration\n      gl.FLOAT, // type - the data is 32bit floats\n      false, // normalize - don't normalize the data\n      0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n      0, // offset - start at the beginning of the buffer\n    );\n\n    /* ======== TEX_COORDS ========= */\n\n    /* prettier-ignore */\n    const texCoords = new Float32Array([\n      0.0,  0.0,\n      1.0,  0.0,\n      1.0,  1.0,\n      1.0,  0.0,\n      0.0,  1.0,\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);\n\n    gl.enableVertexAttribArray(texCoordAttributeLocation);\n    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n    /* ======== INDICES ========= */\n\n    /* prettier-ignore */\n    const indices = new Uint16Array([\n      0, 2, 1,   // 1\n      3, 4, 5,   // 2\n    ]);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint16Array(indices),\n      gl.STATIC_DRAW,\n    );\n\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n\n  const startTime = +new Date();\n\n  (function frame() {\n    const time = (+new Date() - startTime) / 1000;\n\n    const isNeedResize = resizeCanvasToDisplaySize(\n      gl.canvas as HTMLCanvasElement,\n    );\n    if (isNeedResize) {\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    }\n\n    // Clear the canvas\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program);\n\n    gl.uniform1i(image1Location, 0);\n    gl.uniform1i(image2Location, 1);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture1);\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, texture2);\n\n    gl.uniform1f(timeLocation, time);\n    gl.uniform2fv(resolutionLocation, [gl.canvas.width, gl.canvas.height]);\n\n    // Bind the attribute/buffer set we want.\n    gl.bindVertexArray(vao1);\n\n    gl.drawElements(\n      gl.TRIANGLES, // primitiveType\n      6, // count\n      gl.UNSIGNED_SHORT, // indexType\n      0, // offset\n    );\n\n    // Bind the attribute/buffer set we want.\n    gl.bindVertexArray(vao2);\n\n    gl.drawElements(\n      gl.TRIANGLES, // primitiveType\n      6, // count\n      gl.UNSIGNED_SHORT, // indexType\n      0, // offset\n    );\n\n    // Bind the attribute/buffer set we want.\n    gl.bindVertexArray(vao3);\n\n    gl.drawElements(\n      gl.TRIANGLES, // primitiveType\n      6, // count\n      gl.UNSIGNED_SHORT, // indexType\n      0, // offset\n    );\n\n    gl.bindVertexArray(null);\n\n    requestAnimationFrame(frame);\n  })();\n})();\n"],
  "mappings": "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",
  "names": ["createShader", "gl", "type", "source", "shader", "createProgram", "vertexShader", "fragmentShader", "program", "resizeCanvasToDisplaySize", "canvas", "displayWidth", "displayHeight", "needResize", "fragment_default", "vertext_default", "loadImage", "url", "resolve", "image", "images", "canvas", "gl", "vertexShader", "createShader", "vertext_default", "fragmentShader", "fragment_default", "program", "createProgram", "positionAttributeLocation", "texCoordAttributeLocation", "image1Location", "image2Location", "timeLocation", "resolutionLocation", "createTexture", "textureIndex", "texture", "texture1", "texture2", "vao1", "positions", "texCoords", "indices", "vao2", "vao3", "startTime", "frame", "time", "resizeCanvasToDisplaySize"]
}
