{
  "version": 3,
  "sources": ["../../../static/root/0012-webgl-sandbox/_common/utils.ts", "../../../static/root/0012-webgl-sandbox/02-color-triangle/_src/shaders/fragment.glsl", "../../../static/root/0012-webgl-sandbox/02-color-triangle/_src/shaders/vertext.glsl", "../../../static/root/0012-webgl-sandbox/02-color-triangle/_src/index.ts"],
  "sourcesContent": ["export const createShader = (\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string,\n): WebGLShader => {\n  const shader = gl.createShader(type);\n  if (!shader) {\n    throw new Error('createShader failed');\n  }\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    // gl.deleteShader(shader);\n    throw new Error(\n      `could not compile shader: ${gl.getShaderInfoLog(shader) || ''}`,\n    );\n  }\n\n  return shader;\n};\n\nexport const createProgram = (\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram => {\n  const program = gl.createProgram();\n  if (!program) {\n    throw new Error('createProgram failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    // gl.deleteProgram(program);\n    throw new Error(\n      `program failed to link:${gl.getProgramInfoLog(program) || ''}`,\n    );\n  }\n\n  return program;\n};\n\nexport const createAndSetupTexture = (\n  gl: WebGL2RenderingContext,\n): WebGLTexture => {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Set up texture so we can render any size image and so we are\n  // working with pixels.\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  if (texture === null) {\n    throw new Error('texture create fail');\n  }\n\n  return texture;\n};\n\nexport const setCanvasSizeForTexture = (\n  gl: WebGL2RenderingContext,\n  texture: WebGLTexture,\n): void => {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  {\n    // make the texture the same size as the image\n    const mipLevel = 0; // the largest mip\n    const internalFormat = gl.RGBA; // format we want in the texture\n    const border = 0; // must be 0\n    const srcFormat = gl.RGBA; // format of data we are supplying\n    const srcType = gl.UNSIGNED_BYTE; // type of data we are supplying\n    const data = null; // no data = create a blank texture\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      mipLevel,\n      internalFormat,\n      gl.canvas.width,\n      gl.canvas.height,\n      border,\n      srcFormat,\n      srcType,\n      data,\n    );\n  }\n};\n\nexport const resizeCanvasToDisplaySize = (\n  canvas: HTMLCanvasElement,\n): boolean => {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  const displayWidth = canvas.clientWidth;\n  const displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  const needResize =\n    canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n};\n", "export default `#version 300 es\nprecision highp float;in vec4 v_color;out vec4 outColor;void main(){outColor=v_color;}`", "export default `#version 300 es\nin vec4 a_position;in vec4 a_color;out vec4 v_color;void main(){gl_Position=a_position;v_color=a_color;}`", "import {\n  createProgram,\n  createShader,\n  resizeCanvasToDisplaySize,\n} from '../../_common/utils';\n\nimport fragmentShaderSource from './shaders/fragment.glsl';\nimport vertexShaderSource from './shaders/vertext.glsl';\n\nconst getColorsArr = () => {\n  /* prettier-ignore */\n  return new Uint8Array([\n    Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,\n    Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,\n    Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,\n  ])\n};\n\nconst canvas: HTMLCanvasElement | null = document.querySelector('#canvas');\nif (!canvas) {\n  throw new Error('no canvas');\n}\n\nconst gl = canvas.getContext('webgl2');\nif (!gl) {\n  throw new Error('no gl context');\n}\n\nconst vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\nconst fragmentShader = createShader(\n  gl,\n  gl.FRAGMENT_SHADER,\n  fragmentShaderSource,\n);\n\nconst program = createProgram(gl, vertexShader, fragmentShader);\n\nconst positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\nconst colorAttributeLocation = gl.getAttribLocation(program, 'a_color');\n\nconst vao = gl.createVertexArray();\ngl.bindVertexArray(vao);\n\nconst colorBuffer = gl.createBuffer();\n{\n  /* ======== POSITION ========= */\n\n  const positions =\n    /* prettier-ignore */ new Float32Array([\n    -0.8, -0.8,\n    -0.8, 0.8,\n    0.9, .25,\n  ]);\n  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n\n  gl.enableVertexAttribArray(positionAttributeLocation);\n  gl.vertexAttribPointer(\n    positionAttributeLocation,\n    2, // size - 2 components per iteration\n    gl.FLOAT, // type - the data is 32bit floats\n    false, // normalize - don't normalize the data\n    0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n    0, // offset - start at the beginning of the buffer\n  );\n\n  /* ======== COLORS ========= */\n\n  const colorsArr = getColorsArr();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, colorsArr, gl.STATIC_DRAW);\n\n  gl.enableVertexAttribArray(colorAttributeLocation);\n  gl.vertexAttribPointer(\n    colorAttributeLocation,\n    4, // size - 2 components per iteration\n    gl.UNSIGNED_BYTE, // type - the data is 32bit floats\n    true, // normalize - don't normalize the data\n    0, // stride  - 0 = move forward size * sizeof(type) each iteration to get the next position\n    0, // offset - start at the beginning of the buffer\n  );\n}\n\nconst startTime = +new Date();\nlet lastTime;\n(function frame() {\n  const time = (+new Date() - startTime) / 1000;\n\n  if (Math.floor(time * 4) !== Math.floor(lastTime * 4)) {\n    lastTime = time;\n\n    /* ======= UPDATE COLOR ========= */\n\n    /* prettier-ignore */\n    const colorsArr = getColorsArr();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colorsArr, gl.STATIC_DRAW);\n  }\n\n  const isNeedResize = resizeCanvasToDisplaySize(\n    gl.canvas as HTMLCanvasElement,\n  );\n  if (isNeedResize) {\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  }\n\n  // Clear the canvas\n  gl.clearColor(0, 0, 0, 0);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  // Tell it to use our program (pair of shaders)\n  gl.useProgram(program);\n\n  // Bind the attribute/buffer set we want.\n  gl.bindVertexArray(vao);\n\n  gl.drawArrays(\n    gl.TRIANGLES, // primitiveType\n    0, // offset\n    3, // count\n  );\n\n  requestAnimationFrame(frame);\n})();\n"],
  "mappings": "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",
  "names": ["createShader", "gl", "type", "source", "shader", "createProgram", "vertexShader", "fragmentShader", "program", "resizeCanvasToDisplaySize", "canvas", "displayWidth", "displayHeight", "needResize", "fragment_default", "vertext_default", "getColorsArr", "canvas", "gl", "vertexShader", "createShader", "vertext_default", "fragmentShader", "fragment_default", "program", "createProgram", "positionAttributeLocation", "colorAttributeLocation", "vao", "colorBuffer", "positions", "colorsArr", "startTime", "lastTime", "frame", "time", "resizeCanvasToDisplaySize"]
}
